# Blue Carbon MRV Code Fixes - Quick Implementation Guide

## CRITICAL FIXES (Implement First)

### 1. **FIX CRS Bug** - `blue_carbon_config.R` Line 94
```r
# CURRENT (WRONG):
INPUT_CRS <- 3347  # EPSG:4326 (WGS84)

# FIXED:
INPUT_CRS <- 4326  # EPSG:4326 (WGS84)
```

### 2. **Add Bulk Density Uncertainty** - Add to `01_data_prep_bluecarbon.R` after line 113
```r
calculate_soc_stock_with_uncertainty <- function(soc_g_kg, soc_se, bd_g_cm3, bd_se, 
                                                depth_top_cm, depth_bottom_cm) {
  soc_prop <- soc_g_kg / 1000
  depth_increment <- depth_bottom_cm - depth_top_cm
  stock_mean <- soc_prop * bd_g_cm3 * depth_increment / 10
  
  # Error propagation
  rel_var_soc <- if (!is.na(soc_se)) (soc_se / soc_g_kg)^2 else 0.1^2
  rel_var_bd <- if (!is.na(bd_se)) (bd_se / bd_g_cm3)^2 else 0.15^2
  stock_se <- stock_mean * sqrt(rel_var_soc + rel_var_bd)
  
  return(list(mean = stock_mean, se = stock_se))
}
```

### 3. **Fix Equal-Area Spline Name** - `03_depth_harmonization_bluecarbon.R` Line 126
```r
# Change function name from "equal_area_spline" to "cubic_spline_interpolation"
# Or implement true equal-area spline using ithir package:
library(ithir)
equal_area_spline <- function(depths, values, standard_depths) {
  if (length(depths) < 3) return(NULL)
  
  tryCatch({
    ea_result <- ea_spline(depths, values, lambda = 0.1, 
                          d = c(0, 15, 30, 50, 100))
    predictions <- approx(ea_result$depth, ea_result$fitted, 
                         xout = standard_depths, rule = 2)$y
    return(predictions)
  }, error = function(e) NULL)
}
```

---

## HIGH PRIORITY IMPROVEMENTS

### 4. **Add Coordinate Validation** - Add to `01_data_prep_bluecarbon.R` after line 190
```r
# Check for duplicate/clustered cores
locations <- locations %>%
  group_by(round(longitude, 5), round(latitude, 5)) %>%
  mutate(n_at_location = n()) %>%
  ungroup()

if (any(locations$n_at_location > 1)) {
  warning(sprintf("%d locations have multiple cores - check GPS accuracy",
                 sum(locations$n_at_location > 1)))
}
```

### 5. **Add Memory-Safe Processing** - Add to `05_raster_predictions_rf_bluecarbon.R`
```r
# Before line 250, add chunking for large rasters:
safe_mosaic <- function(raster_list, max_cells = 1e7) {
  total_cells <- ncell(raster_list[[1]])
  
  if (total_cells > max_cells) {
    message("Large raster detected - processing in chunks")
    # Process in tiles
    result <- raster_list[[1]]
    for (i in 2:length(raster_list)) {
      result <- merge(result, raster_list[[i]], fun = mean)
    }
    return(result)
  } else {
    return(do.call(mosaic, c(raster_list, list(fun = "mean"))))
  }
}
```

### 6. **Add LOOCV for Small Samples** - Insert in `05_raster_predictions_rf_bluecarbon.R` before RF training
```r
# Around line 300, before model training:
if (nrow(training_data) < 30) {
  log_message("Small sample size - using leave-one-out cross-validation")
  cv_control <- trainControl(method = "LOOCV", savePredictions = TRUE)
} else {
  cv_control <- trainControl(method = "cv", number = CV_FOLDS)
}
```

---

## MEDIUM PRIORITY ENHANCEMENTS

### 7. **Standardize Unit Handling** - Add to all modules
```r
# Create utility function in blue_carbon_config.R:
convert_units <- function(value, from, to) {
  conversions <- list(
    "kg_m2_to_Mg_ha" = 10,
    "Mg_ha_to_kg_m2" = 0.1,
    "g_kg_to_pct" = 0.1,
    "pct_to_g_kg" = 10
  )
  
  key <- paste(from, "to", to, sep = "_")
  if (key %in% names(conversions)) {
    return(value * conversions[[key]])
  } else {
    stop(sprintf("Unknown conversion: %s to %s", from, to))
  }
}
```

### 8. **Add Outlier Detection** - Add to `02_exploratory_analysis_bluecarbon.R`
```r
library(isotree)
detect_outliers <- function(cores_data) {
  numeric_cols <- c("soc", "bulk_density", "depth_cm")
  iso_model <- isolation.forest(cores_data[, numeric_cols])
  scores <- predict(iso_model, cores_data[, numeric_cols])
  outliers <- scores > quantile(scores, 0.95)
  
  cores_data$outlier_flag <- outliers
  n_outliers <- sum(outliers)
  
  if (n_outliers > 0) {
    warning(sprintf("Detected %d potential outliers (%.1f%%)", 
                   n_outliers, 100 * n_outliers / nrow(cores_data)))
  }
  
  return(cores_data)
}
```

### 9. **Add Spatial Autocorrelation Test** - Add to `04_raster_predictions_kriging_bluecarbon.R`
```r
# After variogram fitting, add:
library(spdep)
test_spatial_autocorrelation <- function(residuals, coords) {
  nb <- knn2nb(knearneigh(coords, k = 5))
  listw <- nb2listw(nb, style = "W")
  moran_result <- moran.test(residuals, listw)
  
  if (moran_result$p.value < 0.05) {
    log_message(sprintf("Significant spatial autocorrelation detected (I = %.3f, p = %.4f)",
                       moran_result$estimate[1], moran_result$p.value))
  }
  
  return(moran_result)
}
```

### 10. **Improve Logging** - Replace all `cat()` statements
```r
# In each module, replace cat() with structured logging:
# OLD:
cat(sprintf("Loaded %d cores\n", nrow(cores)))

# NEW:
log_message(sprintf("Loaded %d cores from %d strata", 
                   nrow(cores), n_distinct(cores$stratum)), 
           level = "INFO")
```

---

## VALIDATION ENHANCEMENTS

### 11. **Add Prior Validation** - Add to `00c_bayesian_prior_setup_bluecarbon.R`
```r
validate_prior <- function(prior_raster, field_data, max_bias = 0.2) {
  # Extract prior values at field locations
  prior_values <- extract(prior_raster, field_data[, c("x", "y")])
  
  # Calculate metrics
  bias <- mean(prior_values - field_data$carbon_stock, na.rm = TRUE)
  rmse <- sqrt(mean((prior_values - field_data$carbon_stock)^2, na.rm = TRUE))
  rel_bias <- abs(bias) / mean(field_data$carbon_stock)
  
  if (rel_bias > max_bias) {
    warning(sprintf("Prior shows %.1f%% bias - consider adjustment", rel_bias * 100))
  }
  
  return(list(bias = bias, rmse = rmse, rel_bias = rel_bias))
}
```

### 12. **Add Cross-Validation Metrics** - Enhance `05_raster_predictions_rf_bluecarbon.R`
```r
calculate_cv_metrics <- function(observed, predicted) {
  metrics <- data.frame(
    rmse = sqrt(mean((observed - predicted)^2)),
    mae = mean(abs(observed - predicted)),
    r2 = cor(observed, predicted)^2,
    bias = mean(predicted - observed),
    rel_rmse = sqrt(mean((observed - predicted)^2)) / mean(observed) * 100
  )
  
  log_message(sprintf("CV Metrics: RMSE=%.2f, MAE=%.2f, R²=%.3f, Bias=%.2f, RelRMSE=%.1f%%",
                     metrics$rmse, metrics$mae, metrics$r2, metrics$bias, metrics$rel_rmse))
  
  return(metrics)
}
```

---

## PERFORMANCE OPTIMIZATIONS

### 13. **Enable Parallel Processing** - Add to modules 04 & 05
```r
# At the beginning of modules:
library(future)
library(furrr)
n_cores <- availableCores() - 1
plan(multisession, workers = n_cores)
log_message(sprintf("Parallel processing enabled with %d cores", n_cores))

# Replace lapply with future_map:
# OLD:
models <- lapply(depths, fit_model)

# NEW:
models <- future_map(depths, fit_model, .progress = TRUE)
```

### 14. **Add Caching** - For expensive operations
```r
library(memoise)

# Cache harmonization results
cache_dir <- "cache/"
if (!dir.exists(cache_dir)) dir.create(cache_dir)

harmonize_depths_cached <- memoise(
  harmonize_depths,
  cache = cache_filesystem(cache_dir)
)

# Use cached version in code:
harmonized <- harmonize_depths_cached(core_data, standard_depths)
```

---

## DOCUMENTATION IMPROVEMENTS

### 15. **Add Function Documentation** - Example format
```r
#' Calculate SOC stock with full uncertainty propagation
#'
#' @param soc_g_kg Soil organic carbon content (g/kg)
#' @param soc_se Standard error of SOC (g/kg)
#' @param bd_g_cm3 Bulk density (g/cm³)
#' @param bd_se Standard error of bulk density (g/cm³)
#' @param depth_top_cm Top depth (cm)
#' @param depth_bottom_cm Bottom depth (cm)
#' 
#' @return List with mean and se in kg/m²
#' 
#' @examples
#' stock <- calculate_soc_stock_with_uncertainty(50, 5, 1.2, 0.1, 0, 15)
#' 
#' @export
calculate_soc_stock_with_uncertainty <- function(...) {
  # function body
}
```

---

## TESTING ADDITIONS

### 16. **Add Unit Tests** - Create `tests/test_calculations.R`
```r
library(testthat)

test_that("SOC stock calculation is correct", {
  result <- calculate_soc_stock(soc_g_kg = 50, bd_g_cm3 = 1.2, 
                               depth_top_cm = 0, depth_bottom_cm = 15)
  expect_equal(result, 0.9, tolerance = 0.001)
})

test_that("Unit conversions work", {
  expect_equal(convert_units(1, "kg_m2", "Mg_ha"), 10)
  expect_equal(convert_units(10, "Mg_ha", "kg_m2"), 1)
})

test_that("CRS configuration is valid", {
  expect_equal(INPUT_CRS, 4326)
  expect_true(PROCESSING_CRS %in% c(3005, 3347, 32610, 32611))
})
```

---

## QUICK WINS (5-minute fixes)

1. ✅ Fix CRS configuration (Line 94)
2. ✅ Rename "equal_area_spline" function
3. ✅ Add logging to file in all modules
4. ✅ Standardize decimal places in outputs (TABLE_DIGITS = 2)
5. ✅ Check for missing required packages at start
6. ✅ Add progress messages for long operations
7. ✅ Validate stratum names match between config and data
8. ✅ Add timestamp to all output filenames
9. ✅ Create backup of raw data before processing
10. ✅ Add session info to logs for reproducibility

---

## Implementation Order

### Week 1:
- Critical fixes (#1-3)
- High priority improvements (#4-6)
- Quick wins

### Week 2:
- Medium priority enhancements (#7-10)
- Validation enhancements (#11-12)

### Week 3:
- Performance optimizations (#13-14)
- Documentation (#15)
- Testing (#16)

### Ongoing:
- Monitor memory usage
- Profile slow operations
- Collect user feedback
- Update documentation

---

*Generated for immediate implementation*  
*Priority: Critical > High > Medium > Enhancement*
